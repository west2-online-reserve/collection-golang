// Code generated by hertz generator.

package api

import (
	"context"
	"errors"
	"memogo/biz/dal/db"
	"memogo/biz/dal/repository"
	"memogo/biz/model/memogo/api"
	"memogo/biz/service"
	"memogo/pkg/jwt"
	"memogo/pkg/middleware"
	"strings"
	"time"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
)

// Register .
// @router /v1/auth/register [POST]
func Register(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.RegisterReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	// 创建 service
	userRepo := repository.NewUserRepository(db.DB)
	authService := service.NewAuthService(userRepo)

	// 调用注册服务
	accessToken, refreshToken, err := authService.Register(req.Username, req.Password)
	if err != nil {
		// 根据不同错误返回不同状态码
		if errors.Is(err, repository.ErrUserAlreadyExists) {
			c.JSON(consts.StatusBadRequest, &api.AuthResp{
				Status: 400,
				Msg:    "Username already exists",
			})
			return
		}
		c.JSON(consts.StatusInternalServerError, &api.AuthResp{
			Status: 500,
			Msg:    "Registration failed: " + err.Error(),
		})
		return
	}

	resp := &api.AuthResp{
		Status: 200,
		Msg:    "Registration successful",
		Data: &api.TokenPair{
			AccessToken:      accessToken,
			RefreshToken:     refreshToken,
			AccessExpiresIn:  computeExpiresIn(accessToken),
			RefreshExpiresIn: computeExpiresIn(refreshToken),
		},
	}

	c.JSON(consts.StatusOK, resp)
}

// Login .
// @router /v1/auth/login [POST]
func Login(ctx context.Context, c *app.RequestContext) {
	// 使用 Hertz JWT 中间件的 LoginHandler
	middleware.JWTMiddleware.LoginHandler(ctx, c)
}

// RefreshToken .
// @router /v1/auth/refresh [POST]
func RefreshToken(ctx context.Context, c *app.RequestContext) {
	var req api.RefreshReq
	if err := c.BindAndValidate(&req); err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	refreshToken := strings.TrimSpace(req.GetRefreshToken())
	if refreshToken == "" {
		authHeader := strings.TrimSpace(string(c.Request.Header.Peek("Authorization")))
		if strings.HasPrefix(strings.ToLower(authHeader), "bearer ") {
			refreshToken = strings.TrimSpace(authHeader[len("Bearer "):])
		} else if authHeader != "" {
			refreshToken = authHeader
		}
		if refreshToken == "" {
			c.JSON(consts.StatusBadRequest, &api.AuthResp{
				Status: 400,
				Msg:    "Invalid refresh token",
			})
			return
		}
	}

	userRepo := repository.NewUserRepository(db.DB)
	authService := service.NewAuthService(userRepo)

	accessToken, newRefreshToken, err := authService.RefreshToken(refreshToken)
	if err != nil {
		status := consts.StatusInternalServerError
		msg := "Refresh token failed: " + err.Error()
		switch {
		case errors.Is(err, jwt.ErrExpiredToken):
			status = consts.StatusUnauthorized
			msg = "Refresh token expired"
		case errors.Is(err, jwt.ErrInvalidToken):
			status = consts.StatusUnauthorized
			msg = "Invalid refresh token"
		}

		c.JSON(status, &api.AuthResp{
			Status: int32(status),
			Msg:    msg,
		})
		return
	}

	accessClaims, err := jwt.ParseToken(accessToken)
	if err != nil {
		c.JSON(consts.StatusInternalServerError, &api.AuthResp{
			Status: 500,
			Msg:    "Failed to parse access token: " + err.Error(),
		})
		return
	}
	refreshClaims, err := jwt.ParseToken(newRefreshToken)
	if err != nil {
		c.JSON(consts.StatusInternalServerError, &api.AuthResp{
			Status: 500,
			Msg:    "Failed to parse refresh token: " + err.Error(),
		})
		return
	}

	now := time.Now().Unix()
	var accessExpiresIn int64
	if accessClaims.RegisteredClaims.ExpiresAt != nil {
		accessExpiresIn = accessClaims.RegisteredClaims.ExpiresAt.Unix() - now
		if accessExpiresIn < 0 {
			accessExpiresIn = 0
		}
	}
	var refreshExpiresIn int64
	if refreshClaims.RegisteredClaims.ExpiresAt != nil {
		refreshExpiresIn = refreshClaims.RegisteredClaims.ExpiresAt.Unix() - now
		if refreshExpiresIn < 0 {
			refreshExpiresIn = 0
		}
	}

	resp := &api.AuthResp{
		Status: 200,
		Msg:    "Token refreshed",
		Data: &api.TokenPair{
			AccessToken:      accessToken,
			RefreshToken:     newRefreshToken,
			AccessExpiresIn:  accessExpiresIn,
			RefreshExpiresIn: refreshExpiresIn,
		},
	}

	c.JSON(consts.StatusOK, resp)
}

// CreateTodo .
// @router /v1/todos [POST]
func CreateTodo(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.CreateTodoReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	// 从 JWT 中间件获取用户 ID
	userID, err := middleware.GetUserID(c)
	if err != nil {
		c.JSON(consts.StatusUnauthorized, &api.CreateTodoResp{
			Status: 401,
			Msg:    "Unauthorized: " + err.Error(),
		})
		return
	}

	// 组装服务并创建 Todo
	todoRepo := repository.NewTodoRepository(db.DB)
	todoSvc := service.NewTodoService(todoRepo)

	// 可选时间字段转换（秒 → time.Time）
	var startPtr, duePtr *time.Time
	if req.IsSetStartTime() {
		t := time.Unix(req.GetStartTime(), 0)
		startPtr = &t
	}
	if req.IsSetDueTime() {
		t := time.Unix(req.GetDueTime(), 0)
		duePtr = &t
	}

	todo, err := todoSvc.Create(userID, req.GetTitle(), req.GetContent(), startPtr, duePtr)
	if err != nil {
		// 参数错误 → 400，其它错误 → 500
		status := consts.StatusInternalServerError
		msg := "Create todo failed: " + err.Error()
		if errors.Is(err, service.ErrTitleRequired) || errors.Is(err, service.ErrContentRequired) {
			status = consts.StatusBadRequest
		}
		c.JSON(status, &api.CreateTodoResp{Status: int32(status), Msg: msg})
		return
	}

	// 转为 API 模型
	respTodo := &api.Todo{
		ID:        int64(todo.ID),
		Title:     todo.Title,
		Content:   todo.Content,
		View:      int32(todo.View),
		Status:    api.TodoStatus(todo.Status),
		CreatedAt: todo.CreatedAt.Unix(),
	}
	if todo.StartTime != nil {
		respTodo.StartTime = todo.StartTime.Unix()
	}
	if todo.EndTime != nil {
		respTodo.EndTime = todo.EndTime.Unix()
	}
	if todo.DueTime != nil {
		respTodo.DueTime = todo.DueTime.Unix()
	}

	c.JSON(consts.StatusOK, &api.CreateTodoResp{
		Status: 200,
		Msg:    "ok",
		Data:   respTodo,
	})
}

func computeExpiresIn(token string) int64 {
	claims, err := jwt.ParseToken(token)
	if err != nil || claims.RegisteredClaims.ExpiresAt == nil {
		return 0
	}
	diff := claims.RegisteredClaims.ExpiresAt.Unix() - time.Now().Unix()
	if diff < 0 {
		return 0
	}
	return diff
}

// UpdateTodoStatus .
// @router /v1/todos/{id}/status [PATCH]
func UpdateTodoStatus(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.UpdateTodoStatusReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	// 认证
	userID, err := middleware.GetUserID(c)
	if err != nil {
		c.JSON(consts.StatusUnauthorized, &api.UpdateTodoStatusResp{Status: 401, Msg: "Unauthorized: " + err.Error()})
		return
	}

	todoRepo := repository.NewTodoRepository(db.DB)
	todoSvc := service.NewTodoService(todoRepo)

	affected, err := todoSvc.UpdateTodoStatus(userID, uint(req.GetID()), int32(req.GetStatus()))
	if err != nil {
		c.JSON(consts.StatusInternalServerError, &api.UpdateTodoStatusResp{Status: 500, Msg: "Update failed: " + err.Error()})
		return
	}
	c.JSON(consts.StatusOK, &api.UpdateTodoStatusResp{Status: 200, Msg: "ok", Data: int32(affected)})
}

// UpdateAllStatus .
// @router /v1/todos/status [PATCH]
func UpdateAllStatus(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.UpdateAllStatusReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	userID, err := middleware.GetUserID(c)
	if err != nil {
		c.JSON(consts.StatusUnauthorized, &api.UpdateAllStatusResp{Status: 401, Msg: "Unauthorized: " + err.Error()})
		return
	}

	todoRepo := repository.NewTodoRepository(db.DB)
	todoSvc := service.NewTodoService(todoRepo)

	affected, err := todoSvc.UpdateAllStatus(userID, int32(req.GetFromStatus()), int32(req.GetToStatus()))
	if err != nil {
		c.JSON(consts.StatusInternalServerError, &api.UpdateAllStatusResp{Status: 500, Msg: "Update failed: " + err.Error()})
		return
	}
	c.JSON(consts.StatusOK, &api.UpdateAllStatusResp{Status: 200, Msg: "ok", Data: int32(affected)})
}

// ListTodos .
// @router /v1/todos [GET]
func ListTodos(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.ListTodosReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	userID, err := middleware.GetUserID(c)
	if err != nil {
		c.JSON(consts.StatusUnauthorized, &api.ListTodosResp{Status: 401, Msg: "Unauthorized: " + err.Error()})
		return
	}

	statusStr := strings.ToLower(req.GetStatus())
	page := int(req.GetPage())
	pageSize := int(req.GetPageSize())

	todoRepo := repository.NewTodoRepository(db.DB)
	todoSvc := service.NewTodoService(todoRepo)

	items, total, err := todoSvc.ListTodos(userID, statusStr, page, pageSize)
	if err != nil {
		c.JSON(consts.StatusInternalServerError, &api.ListTodosResp{Status: 500, Msg: "List failed: " + err.Error()})
		return
	}

	apiItems := make([]*api.Todo, 0, len(items))
	for _, t := range items {
		at := &api.Todo{
			ID:        int64(t.ID),
			Title:     t.Title,
			Content:   t.Content,
			View:      int32(t.View),
			Status:    api.TodoStatus(t.Status),
			CreatedAt: t.CreatedAt.Unix(),
		}
		if t.StartTime != nil {
			at.StartTime = t.StartTime.Unix()
		}
		if t.EndTime != nil {
			at.EndTime = t.EndTime.Unix()
		}
		if t.DueTime != nil {
			at.DueTime = t.DueTime.Unix()
		}
		apiItems = append(apiItems, at)
	}

	c.JSON(consts.StatusOK, &api.ListTodosResp{
		Status: 200,
		Msg:    "ok",
		Data: &api.ItemsTodoData{
			Items: apiItems,
			Total: total,
		},
	})
}

// SearchTodos .
// @router /v1/todos/search [GET]
func SearchTodos(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.SearchTodosReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	userID, err := middleware.GetUserID(c)
	if err != nil {
		c.JSON(consts.StatusUnauthorized, &api.SearchTodosResp{Status: 401, Msg: "Unauthorized: " + err.Error()})
		return
	}

	q := req.GetQ()
	page := int(req.GetPage())
	pageSize := int(req.GetPageSize())

	todoRepo := repository.NewTodoRepository(db.DB)
	todoSvc := service.NewTodoService(todoRepo)
	items, total, err := todoSvc.SearchTodos(userID, q, page, pageSize)
	if err != nil {
		c.JSON(consts.StatusInternalServerError, &api.SearchTodosResp{Status: 500, Msg: "Search failed: " + err.Error()})
		return
	}

	apiItems := make([]*api.Todo, 0, len(items))
	for _, t := range items {
		at := &api.Todo{
			ID:        int64(t.ID),
			Title:     t.Title,
			Content:   t.Content,
			View:      int32(t.View),
			Status:    api.TodoStatus(t.Status),
			CreatedAt: t.CreatedAt.Unix(),
		}
		if t.StartTime != nil {
			at.StartTime = t.StartTime.Unix()
		}
		if t.EndTime != nil {
			at.EndTime = t.EndTime.Unix()
		}
		if t.DueTime != nil {
			at.DueTime = t.DueTime.Unix()
		}
		apiItems = append(apiItems, at)
	}

	c.JSON(consts.StatusOK, &api.SearchTodosResp{
		Status: 200,
		Msg:    "ok",
		Data: &api.ItemsTodoData{
			Items: apiItems,
			Total: total,
		},
	})
}

// DeleteOne .
// @router /v1/todos/{id} [DELETE]
func DeleteOne(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.DeleteOneReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	userID, err := middleware.GetUserID(c)
	if err != nil {
		c.JSON(consts.StatusUnauthorized, &api.DeleteResp{Status: 401, Msg: "Unauthorized: " + err.Error()})
		return
	}

	todoRepo := repository.NewTodoRepository(db.DB)
	todoSvc := service.NewTodoService(todoRepo)
	affected, err := todoSvc.DeleteOne(userID, uint(req.GetID()))
	if err != nil {
		c.JSON(consts.StatusInternalServerError, &api.DeleteResp{Status: 500, Msg: "Delete failed: " + err.Error()})
		return
	}
	c.JSON(consts.StatusOK, &api.DeleteResp{Status: 200, Msg: "ok", Data: int32(affected)})
}

// DeleteByScope .
// @router /v1/todos [DELETE]
func DeleteByScope(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.DeleteByScopeReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	userID, err := middleware.GetUserID(c)
	if err != nil {
		c.JSON(consts.StatusUnauthorized, &api.DeleteResp{Status: 401, Msg: "Unauthorized: " + err.Error()})
		return
	}

	scope := strings.ToLower(req.GetScope())
	if scope != "done" && scope != "todo" && scope != "all" {
		c.JSON(consts.StatusBadRequest, &api.DeleteResp{Status: 400, Msg: "invalid scope"})
		return
	}

	todoRepo := repository.NewTodoRepository(db.DB)
	todoSvc := service.NewTodoService(todoRepo)
	affected, err := todoSvc.DeleteByScope(userID, scope)
	if err != nil {
		c.JSON(consts.StatusInternalServerError, &api.DeleteResp{Status: 500, Msg: "Delete failed: " + err.Error()})
		return
	}
	c.JSON(consts.StatusOK, &api.DeleteResp{Status: 200, Msg: "ok", Data: int32(affected)})
}

// ListTodosCursor .
// @router /v1/todos/cursor [GET]
func ListTodosCursor(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.ListTodosCursorReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	// 获取用户 ID
	userID, err := middleware.GetUserID(c)
	if err != nil {
		c.JSON(consts.StatusUnauthorized, &api.ListTodosCursorResp{Status: 401, Msg: "Unauthorized: " + err.Error()})
		return
	}

	statusStr := strings.ToLower(req.GetStatus())
	cursor := uint(req.GetCursor())
	limit := int(req.GetLimit())

	todoRepo := repository.NewTodoRepository(db.DB)
	todoSvc := service.NewTodoService(todoRepo)

	items, nextCursor, hasMore, err := todoSvc.ListTodosCursor(userID, statusStr, cursor, limit)
	if err != nil {
		c.JSON(consts.StatusInternalServerError, &api.ListTodosCursorResp{Status: 500, Msg: "Query failed: " + err.Error()})
		return
	}

	// 转换为 API 模型
	apiItems := make([]*api.Todo, 0, len(items))
	for _, t := range items {
		at := &api.Todo{
			ID:        int64(t.ID),
			Title:     t.Title,
			Content:   t.Content,
			View:      int32(t.View),
			Status:    api.TodoStatus(t.Status),
			CreatedAt: t.CreatedAt.Unix(),
		}
		if t.StartTime != nil {
			at.StartTime = t.StartTime.Unix()
		}
		if t.EndTime != nil {
			at.EndTime = t.EndTime.Unix()
		}
		if t.DueTime != nil {
			at.DueTime = t.DueTime.Unix()
		}
		apiItems = append(apiItems, at)
	}

	c.JSON(consts.StatusOK, &api.ListTodosCursorResp{
		Status: 200,
		Msg:    "ok",
		Data: &api.CursorTodoData{
			Items:      apiItems,
			NextCursor: int64(nextCursor),
			HasMore:    hasMore,
		},
	})
}

// SearchTodosCursor .
// @router /v1/todos/search/cursor [GET]
func SearchTodosCursor(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.SearchTodosCursorReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	// 获取用户 ID
	userID, err := middleware.GetUserID(c)
	if err != nil {
		c.JSON(consts.StatusUnauthorized, &api.SearchTodosCursorResp{Status: 401, Msg: "Unauthorized: " + err.Error()})
		return
	}

	keyword := req.GetQ()
	cursor := uint(req.GetCursor())
	limit := int(req.GetLimit())

	todoRepo := repository.NewTodoRepository(db.DB)
	todoSvc := service.NewTodoService(todoRepo)

	items, nextCursor, hasMore, err := todoSvc.SearchTodosCursor(userID, keyword, cursor, limit)
	if err != nil {
		c.JSON(consts.StatusInternalServerError, &api.SearchTodosCursorResp{Status: 500, Msg: "Search failed: " + err.Error()})
		return
	}

	// 转换为 API 模型
	apiItems := make([]*api.Todo, 0, len(items))
	for _, t := range items {
		at := &api.Todo{
			ID:        int64(t.ID),
			Title:     t.Title,
			Content:   t.Content,
			View:      int32(t.View),
			Status:    api.TodoStatus(t.Status),
			CreatedAt: t.CreatedAt.Unix(),
		}
		if t.StartTime != nil {
			at.StartTime = t.StartTime.Unix()
		}
		if t.EndTime != nil {
			at.EndTime = t.EndTime.Unix()
		}
		if t.DueTime != nil {
			at.DueTime = t.DueTime.Unix()
		}
		apiItems = append(apiItems, at)
	}

	c.JSON(consts.StatusOK, &api.SearchTodosCursorResp{
		Status: 200,
		Msg:    "ok",
		Data: &api.CursorTodoData{
			Items:      apiItems,
			NextCursor: int64(nextCursor),
			HasMore:    hasMore,
		},
	})
}
