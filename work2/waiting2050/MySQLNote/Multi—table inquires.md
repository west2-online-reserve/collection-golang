# 数据库多表设计与查询

## 一、多表关系

### 1.1 概述
在数据库设计中，表与表之间的关系由业务逻辑决定，主要分为三种类型：
- 一对多（多对一）
- 多对多
- 一对一


#### 1.1.1 一对多（多对一）
- **案例**：部门与员工的关系  
- **关系**：一个部门可包含多个员工，一个员工仅属于一个部门  
- **实现方式**：在"多"的一方（员工表）中添加外键，指向"一"的一方（部门表）的主键  

| 员工表(emp)       |        |        |            | 部门表(dept)       |        |
|-------------------|--------|--------|------------|--------------------|--------|
| id                | name   | age    | dept_id（外键） | id                 | name   |
| 1                 | 张无忌 | 20     | 1          | 1                  | 研发部 |
| 2                 | 杨逍   | 33     | 1          | 2                  | 市场部 |
| 3                 | 赵敏   | 18     | 2          | 3                  | 财务部 |
| 4                 | 常遇春 | 43     | 2          | 4                  | 销售部 |


#### 1.1.2 多对多
- **案例**：学生与课程的关系  
- **关系**：一个学生可选修多门课程，一门课程可被多个学生选修  
- **实现方式**：新增中间表（如学生课程关系表），包含两个外键分别关联双方主键  

| 学生表(student)   |        |          |
|-------------------|--------|----------|
| id                | name   | no       |
| 1                 | 黛绮丝 | 2000100101 |
| 2                 | 谢逊   | 2000100102 |
| 3                 | 殷天正 | 2000100103 |
| 4                 | 韦一笑 | 2000100104 |

| 学生课程关系表(student_course) |            |            |
|--------------------------------|------------|------------|
| id                             | studentid（外键） | courseid（外键） |
| 1                              | 1          | 1          |
| 2                              | 1          | 2          |
| 3                              | 1          | 3          |
| 4                              | 2          | 1          |
| 5                              | 2          | 4          |

| 课程表(course)    |        |
|-------------------|--------|
| id                | name   |
| 1                 | Java   |
| 2                 | PHP    |
| 3                 | MySQL  |
| 4                 | Hadoop |


#### 1.1.3 一对一
- **案例**：用户与用户详情的关系  
- **关系**：一对一用于单表拆分，将基础字段与详情字段分离以提升效率  
- **实现方式**：在任意一方添加外键关联另一方主键，并设置外键为唯一（UNIQUE）  

| 用户基本信息表(tb_user) |        |       |        |          |
|-------------------------|--------|-------|--------|----------|
| id                      | name   | age   | gender | phone    |
| 1                       | 黄渤   | 45    | 1      | 18800001111 |
| 2                       | 冰冰   | 35    | 2      | 18800002222 |
| 3                       | 码云   | 55    | 1      | 18800008888 |
| 4                       | 李彦宏 | 50    | 1      | 18800009999 |

| 用户教育信息表(tb_user_edu) |        |        |                  |                  |             |        |
|-----------------------------|--------|--------|------------------|------------------|-------------|--------|
| id                          | degree | major  | primaryschool    | middleschool     | university  | userid（外键+唯一） |
| 1                           | 本科   | 舞蹈   | 静安区第一小学   | 静安区第一中学   | 北京舞蹈学院 | 1      |
| 2                           | 硕士   | 表演   | 朝阳区第一小学   | 朝阳区第一中学   | 北京电影学院 | 2      |
| 3                           | 本科   | 英语   | 杭州市第一小学   | 杭州市第一中学   | 杭州师范大学 | 3      |
| 4                           | 本科   | 应用数学 | 阳泉第一小学     | 阳泉区第一中学   | 清华大学    | 4      |


# 二、多表查询概述

## 2.1 多表查询分类

### 2.1.1 连接查询
连接查询是通过表间的关联关系（如外键）将多个表的数据组合查询，主要包括以下类型：
- **内连接**：仅返回两张表中符合连接条件的交集数据  
- **外连接**：  
  - 左外连接：返回左表全部数据 + 两表交集部分数据（右表无匹配时用 NULL 填充）  
  - 右外连接：返回右表全部数据 + 两表交集部分数据（左表无匹配时用 NULL 填充）  
- **自连接**：将表与自身视为两张不同的表进行连接（需通过表别名区分）  

![连接查询示意图](https://github.com/waiting2050/go_learning/blob/main/erlun/MySQLNote/markdown-images/%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E7%A4%BA%E6%84%8F%E5%9B%BE.png?raw=true)


### 2.1.2 子查询
子查询是嵌套在其他 SQL 语句（如 `SELECT`、`INSERT`、`UPDATE` 等）中的查询语句，作用包括：
- 作为条件判断（如 `WHERE` 子句中的筛选条件）  
- 作为数据源（如 `FROM` 子句中的临时结果集）  
- 作为字段值（如 `SELECT` 子句中的计算结果）  


## 2.2 内连接查询
内连接用于获取两张表中满足连接条件的共有数据，是最常用的连接方式之一。

#### 语法示例
##### 隐式内连接（传统写法）
```sql
SELECT 字段列表 
FROM 表1, 表2 
WHERE 表1.关联字段 = 表2.关联字段  -- 连接条件
  AND 筛选条件;  -- 数据筛选条件
```

##### 显式内连接（推荐写法）
```sql
SELECT 字段列表 
FROM 表1 
[INNER] JOIN 表2  -- INNER 可省略
  ON 表1.关联字段 = 表2.关联字段  -- 连接条件单独声明
WHERE 筛选条件;  -- 筛选条件与连接条件分离
```

**示例说明**：  
若查询员工表（`emp`）和部门表（`dept`）中「研发部」的员工信息，显式内连接写法更清晰：
```sql
SELECT emp.name, dept.name 
FROM emp 
JOIN dept ON emp.dept_id = dept.id 
WHERE dept.name = '研发部';
```


## 2.3 外连接查询
外连接用于保留某一张表的全部数据，同时关联另一张表的匹配数据，适合需要完整展示主表信息的场景。

#### 语法示例
##### 左外连接
```sql
SELECT 字段列表 
FROM 左表 
LEFT [OUTER] JOIN 右表  -- OUTER 可省略
  ON 左表.关联字段 = 右表.关联字段;
```
**说明**：始终返回左表的所有记录，右表无匹配时相关字段显示为 `NULL`。

##### 右外连接
```sql
SELECT 字段列表 
FROM 左表 
RIGHT [OUTER] JOIN 右表  -- OUTER 可省略
  ON 左表.关联字段 = 右表.关联字段;
```
**说明**：始终返回右表的所有记录，左表无匹配时相关字段显示为 `NULL`。

**示例说明**：  
查询所有部门（包括暂无员工的部门）及其下属员工，可用右外连接：
```sql
SELECT dept.name, emp.name 
FROM emp 
RIGHT JOIN dept ON emp.dept_id = dept.id;
```


## 2.4 自连接查询
自连接是特殊的连接方式，将同一张表视为两张逻辑上独立的表（通过别名区分），常用于查询表内具有层级或关联关系的数据（如员工与上级的关系）。

#### 语法示例
```sql
SELECT 别名A.字段1, 别名B.字段2 
FROM 表 别名A 
[INNER/LEFT/RIGHT] JOIN 表 别名B  -- 支持内连接或外连接
  ON 别名A.关联字段 = 别名B.关联字段;  -- 表内关联条件
```

**示例说明**：  
查询员工及其直属上级的姓名（假设员工表 `emp` 中 `manager_id` 字段关联上级的 `id`）：
```sql
SELECT a.name AS '员工', b.name AS '上级' 
FROM emp a 
LEFT JOIN emp b ON a.manager_id = b.id;
```
（使用左外连接可保留无上级的员工记录）

# 三、联合查询（UNION、UNION ALL）

联合查询的作用是将**多次查询的结果合并**，形成一个新的查询结果集。


### 语法格式
```sql
SELECT 字段列表 FROM 表A ...
UNION [ALL]
SELECT 字段列表 FROM 表B ...;
```


### 核心规则
1. **列数与类型一致**：参与联合的多张表，**列数必须相同**，且对应位置的**字段类型需兼容**（如 `INT` 和 `VARCHAR` 可能因类型不匹配报错）。  
2. **去重与保留全部**：  
   - `UNION`：会对合并后的结果**自动去重**（性能开销较大）。  
   - `UNION ALL`：直接合并所有数据，**保留重复项**（性能更优）。  


### 示例对比
假设存在表 `table_a` 和 `table_b`，结构如下：

| table_a（id INT, name VARCHAR） |        |
|--------------------------------|--------|
| id                             | name   |
| 1                              | Alice  |
| 2                              | Bob    |
| 3                              | Alice  |

| table_b（id INT, name VARCHAR） |        |
|--------------------------------|--------|
| id                             | name   |
| 2                              | Bob    |
| 4                              | Cindy  |


#### 1. 使用 `UNION`
```sql
SELECT id, name FROM table_a
UNION
SELECT id, name FROM table_b;
```
**结果**（去重后）：
| id | name  |
|----|-------|
| 1  | Alice |
| 2  | Bob   |
| 3  | Alice |
| 4  | Cindy |


#### 2. 使用 `UNION ALL`
```sql
SELECT id, name FROM table_a
UNION ALL
SELECT id, name FROM table_b;
```
**结果**（保留所有重复项）：
| id | name  |
|----|-------|
| 1  | Alice |
| 2  | Bob   |
| 3  | Alice |
| 2  | Bob   |
| 4  | Cindy |


### 适用场景
- 若需**合并结果且去重**，用 `UNION`（如合并两个不同来源的唯一数据）。  
- 若需**合并所有结果（包括重复）**且追求性能，用 `UNION ALL`（如日志合并、批量数据聚合）。

# 四、子查询

## 概念
SQL 语句中嵌套 `SELECT` 语句，称为**嵌套查询**，又称**子查询**。

**语法示例**：
```sql
SELECT * FROM t1 WHERE column1 = (SELECT column1 FROM t2);
```

子查询外部的语句可以是 `INSERT`、`UPDATE`、`DELETE`、`SELECT` 中的任何一个。


### 分类（按子查询结果不同）
- **标量子查询**：子查询结果为**单个值**（如一个数字、字符串）。
- **列子查询**：子查询结果为**一列数据**（如某字段的所有取值）。
- **行子查询**：子查询结果为**一行数据**（多列但仅一行）。
- **表子查询**：子查询结果为**多行多列**（类似一张临时表）。


### 分类（按子查询位置不同）
- `WHERE` 之后：子查询作为 `WHERE` 子句的筛选条件（如上述示例）。
- `FROM` 之后：子查询结果作为临时表，供外层查询 `FROM` 子句使用。
- `SELECT` 之后：子查询结果作为字段值，出现在 `SELECT` 子句中。


## 标量子查询
- 子查询返回的结果是单个值（数字、字符串、日期等），是最简单的子查询形式，这种子查询称为**标量子查询**。
- 常用的操作符：`=`、`<>`、`>`、`>=`、`<`、`<=`

## 列子查询
- 子查询返回的结果是一列（可以是多行），这种子查询称为**列子查询**。
- 常用的操作符：`IN`、`NOT IN`、`ANY`、`SOME`、`ALL`

| 操作符 | 描述 |
| --- | --- |
| `IN` | 在指定的集合范围之内，多选一 |
| `NOT IN` | 不在指定的集合范围之内 |
| `ANY` | 子查询返回列表中，有任意一个满足即可 |
| `SOME` | 与`ANY`等同，使用`SOME`的地方都可以使用`ANY` |
| `ALL` | 子查询返回列表的所有值都必须满足 |

## 行子查询
- 子查询返回的结果是一行（可以是多列），这种子查询称为**行子查询**。
- 常用的操作符：`=`、`<>`、`IN`、`NOT IN`

## 表子查询
- 子查询返回的结果是多行多列，这种子查询称为**表子查询**。
- 常用的操作符：`IN`