```go
package main

import (
	"fmt"
)

func generate(ch chan int) {
	for i := 2; ; i++ {
		ch <- i
	}
}

func filter(in chan int, out chan int, prime int) {
	for {
		num := <-in
		if num%prime != 0 {
			out <- num
		}
	}
}

func main() {
	ch := make(chan int)
	go generate(ch)
	for i := 0; i < 6; i++ {
		prime := <-ch 
		fmt.Printf("prime:%d\n", prime)
		out := make(chan int)
		go filter(ch, out, prime)
		ch = out
	}
}
```

看一眼变量名，不用运行也知道，这是一个筛选素数的程序，应用了`Go`语言的通道特性。  
`generate`函数用于生成自然数序列，从2开始无限生成自然数，然后将它们发送到通道ch中。  
`filter`函数用于筛选素数，它接收自然数从输入通道`in`中，并检查是否为给定素数`prime`的倍数，如果不是，则将自然数发送到输出通道`out`中。  
在main函数中，首先创建一个通道`ch`，然后启动一个生成器协程来生成自然数序列。  
程序循环6次，每次筛选出一个素数，然后输出该素数的值。最终，程序会生成前6个素数：2、3、5、7、11、13。  

```
分割线，我要开始吐槽了。
（以下纯主观，如果你有反对意见，那你是对的）
```

在我看来，这个程序表现其实很差。这并不是go的问题，而是在实现功能的时候，使用了错误实现方法。  
第一就是，go的通道适合高并发场景使用。但是筛选素数并不是高并发场景。因此，整个程序的可读性并不是那么好。  
第二，程序仅输出了6个素数，却使用了一个无限生成的数列的协程，势必造成内存上的浪费。  
第三，如果把性能提升，仅仅局限于运行速度上的变快，那显然是有的。但是，在我测试下，速度提升不到5%（约4.78%），但是内存占用提升了12%。此时，对是否有性能提升这个问题，我认为是有不同意见的。  
</br>
但是，这很大程度上，是在错误场景使用了错误算法导致的。